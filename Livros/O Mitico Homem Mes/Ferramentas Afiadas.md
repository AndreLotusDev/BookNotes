---
aliases: 
tags: 
date created: Friday, April 25th 2025, 2:27:02 pm
date modified: Friday, April 25th 2025, 2:37:16 pm
---
É interessante notar que esse capítulo em si é uma viagem no tempo, e muitos das soluções que ofertamos hoje é em prol dos problemas elencados nesse capítulo.

---

O capítulo começa dando a enfase dos projetos terem um ferramenteiro, aquele cujo o objetivo é manter de certa forma a homogeneidade, afinal um ambiente com as pessoas utilizando as mesmas ferramentas garante a integridade, qualidade e consistência, e claro podemos compartilhar experiências e dicas de produtividade ao utilizar as mesmas ferramentas.

Ao mesmo tempo que controlar é importante, ter liberdade e permitir/reconhecer a necessidade de se precisar de ferramentas especializadas em certos momentos é de suma importância também.

O capítulo também cita um problema que transcende as decadas, de máquinas onde se projetam o código são diferentes do ambiente onde se faz o deploy, tivemos algumas soluções ao longo do tempo, mas a de longe mais importante é o docker, os computadores hoje em dia possuem alto poder computacional permitindo emolução de outros sistemas dentro de um sistema a priori, todavia o docker eleva isso a outra potência, pois evita overhead e custos desnecessários, sendo extremamente level e modularizavel, podendo se utilizar vários OS's reutilizando layers entre si.

#### Linguagem de alto nível

É legal de se ver como o autor elenca que há perca de performance sobre as linguagem de baixo nível, todavia há inúmeros beneficios, principalmente ao que tange produtividade e capacidade de manter sistemas em linguagens de alto nível.

Fora de que, linguagens de alto nível possuem compiladores, ao que ao final do dia produz código muito melhor que muitos programadores escrevendo código de baixo nível diretamente.

Na época o exemplo utilizado era PL/I. Ele também demonstra por gráficos que linguagem interativas são no mínimo duas vezes mais produtivas que linguagens de batches.